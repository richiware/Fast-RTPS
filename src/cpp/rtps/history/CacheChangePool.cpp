// Copyright 2016 Proyectos y Sistemas de Mantenimiento SL (eProsima).
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

/**
 * @file CacheChangePool.cpp
 *
 */

#include <fastrtps/rtps/history/CacheChangePool.h>
#include <fastrtps/rtps/common/CacheChange.h>
#include <fastrtps/log/Log.h>

#include <cassert>

using namespace eprosima::fastrtps::rtps;

void CacheChangePoolDeleter::operator()(CacheChange_t* cachechange)
{
    if(pool_)
    {
        pool_->release_cache(cachechange);
    }
}

//TODO(Ricardo) Type size generated by fastrtpsgen using constexpr
CacheChangePool::CacheChangePool(const int32_t pool_size, const uint32_t payload_size, const int32_t max_pool_size) :
    payload_size_(0), pool_size_(0), max_pool_size_(0)
{
    logInfo(RTPS_UTILS,"Creating CacheChangePool of size: " << pool_size << " with payload of size: " << payload_size);

    payload_size_ = payload_size;
    pool_size_ = 0;
    if(max_pool_size > 0)
    {
        if(pool_size > max_pool_size)
        {
            max_pool_size_ = (uint32_t)abs(pool_size);
        }
        else
            max_pool_size_ = (uint32_t)abs(max_pool_size);
    }
}

CacheChangePool::~CacheChangePool()
{
    //Deletion process does not depend on the memory management policy
    for(auto* change : free_caches_)
    {
        delete(change);
    }
}

CacheChange_ptr CacheChangePool::reserve_cache()
{
    std::lock_guard<std::mutex> guard(mutex_);

    if(free_caches_.empty())
    {
        if (!allocate_group_nts((uint16_t)(ceil((float)pool_size_ / 10) + 10)))
        {
            return CacheChange_ptr();
        }
    }

    CacheChange_t* change = free_caches_.back();
    free_caches_.erase(free_caches_.end() - 1);
    return CacheChange_ptr(this, change);
}

void CacheChangePool::release_cache(CacheChange_t* cachechange)
{
    cachechange->kind = ALIVE;
    cachechange->sequence_number.high = 0;
    cachechange->sequence_number.low = 0;
    cachechange->writer_guid = c_Guid_Unknown;
    cachechange->serialized_payload.length = 0;
    cachechange->serialized_payload.pos = 0;
    for(uint8_t i=0;i<16;++i)
        cachechange->instance_handle.value[i] = 0;
    cachechange->is_read = 0;
    cachechange->source_timestamp.seconds = 0;
    cachechange->source_timestamp.fraction = 0;
    cachechange->setFragmentSize(0);

    std::lock_guard<std::mutex> guard(mutex_);
    free_caches_.push_back(cachechange);
}

bool CacheChangePool::allocate_group_nts(uint32_t group_size)
{
    logInfo(RTPS_UTILS,"Allocating group of cache changes of size: "<< group_size);
    uint32_t reserved = 0;
    bool returned_value = false;

    if (max_pool_size_ == 0)
    {
        reserved = group_size;
    }
    else
    {
        if(pool_size_ + group_size > max_pool_size_)
        {
            reserved = max_pool_size_ - pool_size_;
        }
        else
        {
            reserved = group_size;
        }
    }

    if(reserved > 0)
    {
        for(uint32_t i = 0; i < reserved; ++i)
        {
            CacheChange_t* ch = new CacheChange_t(payload_size_);
            free_caches_.push_back(ch);
        }

        pool_size_ += reserved;
        returned_value = true;
    }

    return returned_value;
}
